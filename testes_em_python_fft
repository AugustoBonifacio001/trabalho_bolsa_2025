# -*- coding: utf-8 -*-
"""
Created on Mon Feb 24 09:39:19 2025

@author: josea
"""

# -*- coding: utf-8 -*-
"""
Reconstrução de sinal usando FFT e OMP
"""

import numpy as np
import matplotlib.pyplot as plt
import scipy.fftpack as spfft
from sklearn.linear_model import OrthogonalMatchingPursuit

# Função para calcular o PRD

def calculate_prd(original, reconstructed):
    return (np.linalg.norm(original - np.real(reconstructed)) / np.linalg.norm(original)) * 100

#def calculate_prd(original, reconstructed):
    #return np.sqrt(np.sum((original - reconstructed) ** 2) / np.sum(original ** 2)) * 100

# Função para calcular o Erro Médio Quadrático (RMSE)
def calculate_rmse(original, reconstructed):
    return np.sqrt(np.mean((original - reconstructed) ** 2))

# Parâmetros do sinal
Nppc = 136.53  # Número de pontos por ciclo
Nc = 12         # Número de ciclos
f = 60          # Frequência fundamental (Hz)
Fs = 8192       # Frequência de amostragem
Ts = 1 / Fs     # Período de amostragem
t = np.linspace(0, (Fs - 1) * Ts, Fs)  # Vetor de tempo

# Sinal harmônico com componentes fundamentais e harmônicos ímpares
x = np.cos(2 * np.pi * f * t)  # Componente fundamental (60 Hz)
y = np.zeros_like(x)

harm = [1, 3, 7, 15, 27, 35, 45]
for h in harm:
    y += (1 / h) * np.cos(2 * np.pi * h * f * t)

# FFT do sinal original
original_fft = 2 * np.abs(np.fft.fft(y) / len(y))[:len(y) // 2]
frequencies = np.fft.fftfreq(len(y), d=Ts)[:len(y) // 2]

# Amostragem Compressiva
CR = 50  # Taxa de compressão
N = Fs
M = int(N * (100 - CR) / 100)  # Número de medições
amostras_aleatorias = np.random.choice(N, M, replace=False)
amostras_aleatorias.sort()
s = y[amostras_aleatorias]
t2 = t[amostras_aleatorias]

# Matriz de medição usando FFT
A = np.real(spfft.fft(np.identity(N)))
A = A[amostras_aleatorias]

# Inicializando os erros
erros = np.zeros((200, 7))
rmse_values = np.zeros(200)

# Loop de reconstrução
for i in range(200):
    print(f"Iteração {i + 1} de 200 ({(i + 1) / 200 * 100:.1f}%)")

    # Aplicando OMP para reconstrução do sinal
    omp = OrthogonalMatchingPursuit(n_nonzero_coefs=10)
    omp.fit(A, s)
    recovered_signal = omp.coef_

    # Reconstrução do sinal a partir da FFT inversa
    sig = np.fft.ifft(recovered_signal)

    # Calculando PRD e RMSE
    prd_value = calculate_prd(y, np.real(sig))
    rmse_values[i] = calculate_rmse(y, np.real(sig))

    # FFT do sinal reconstruído
    S = 2 * np.abs(np.fft.fft(sig) / len(sig))[:len(sig) // 2]

    # Cálculo dos erros nas harmônicas
    indices_harm = [12, 36, 84, 180, 324, 420, 540]
    for j, idx in enumerate(indices_harm):
        erros[i, j] = np.abs(original_fft[idx] - S[idx])

# Cálculo das médias
media_erros = np.mean(erros, axis=0)
media_rmse = np.mean(rmse_values)

# Exibindo os resultados
print("\nMédia dos erros por harmônica:")
for i, h in enumerate(harm):
    print(f"Harmônica {h}: {media_erros[i]:.3f}")

print(f"\nMédia do Erro Médio Quadrático (RMSE): {media_rmse:.4f}")
print(f"Média do PRD: {prd_value:.4f}%")

# Plot do sinal reconstruído
plt.figure(figsize=(12, 6))
plt.plot(t, y, label='Sinal Original')
plt.plot(t, np.real(sig), label=f'Sinal Reconstruído (PRD={prd_value:.2f}%)', linestyle='--')
plt.xlabel('Tempo (s)')
plt.ylabel('Amplitude')
plt.legend()
plt.title('Sinal Original vs. Reconstruído')
plt.grid()
plt.show()

# Comparação das FFTs
plt.figure(figsize=(12, 6))
plt.plot(frequencies, original_fft, label='FFT do Sinal Original')
plt.plot(frequencies, S, label='FFT do Sinal Reconstruído', linestyle='--')
plt.xlabel('Frequência (Hz)')
plt.ylabel('Amplitude')
plt.legend()
plt.title('Comparação das FFTs')
plt.grid()
plt.show()
